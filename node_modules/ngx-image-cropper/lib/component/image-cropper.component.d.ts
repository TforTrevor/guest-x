import { ChangeDetectorRef, ElementRef, EventEmitter, OnChanges, OnInit, SimpleChanges } from '@angular/core';
import { DomSanitizer, SafeStyle, SafeUrl } from '@angular/platform-browser';
import { CropperPosition, Dimensions, ImageCroppedEvent, ImageTransform } from '../interfaces';
import { MoveTypes } from '../interfaces/move-start.interface';
import * as ɵngcc0 from '@angular/core';
export declare class ImageCropperComponent implements OnChanges, OnInit {
    private sanitizer;
    private cd;
    private Hammer;
    private originalImage;
    private transformedImage;
    private originalBase64;
    private transformedBase64;
    private moveStart;
    private originalSize;
    private transformedSize;
    private setImageMaxSizeRetries;
    private cropperScaledMinWidth;
    private cropperScaledMinHeight;
    private exifTransform;
    private autoRotateSupported;
    private stepSize;
    safeImgDataUrl: SafeUrl | string;
    safeTransformStyle: SafeStyle | string;
    marginLeft: SafeStyle | string;
    maxSize: Dimensions;
    imageVisible: boolean;
    moveTypes: typeof MoveTypes;
    wrapper: ElementRef;
    sourceImage: ElementRef;
    imageChangedEvent: any;
    imageURL: string;
    imageBase64: string;
    imageFile: File;
    format: 'png' | 'jpeg' | 'bmp' | 'webp' | 'ico';
    maintainAspectRatio: boolean;
    transform: ImageTransform;
    aspectRatio: number;
    resizeToWidth: number;
    resizeToHeight: number;
    cropperMinWidth: number;
    cropperMinHeight: number;
    canvasRotation: number;
    initialStepSize: number;
    roundCropper: boolean;
    onlyScaleDown: boolean;
    imageQuality: number;
    autoCrop: boolean;
    backgroundColor: string;
    containWithinAspectRatio: boolean;
    hideResizeSquares: boolean;
    cropper: CropperPosition;
    alignImage: 'left' | 'center';
    disabled: boolean;
    imageCropped: EventEmitter<ImageCroppedEvent>;
    startCropImage: EventEmitter<void>;
    imageLoaded: EventEmitter<void>;
    cropperReady: EventEmitter<Dimensions>;
    loadImageFailed: EventEmitter<void>;
    constructor(sanitizer: DomSanitizer, cd: ChangeDetectorRef);
    ngOnChanges(changes: SimpleChanges): void;
    private onChangesInputImage;
    private isValidImageChangedEvent;
    private setCssTransform;
    ngOnInit(): void;
    private initCropper;
    private loadImage;
    private loadImageFile;
    private isValidImageType;
    private loadBase64Image;
    private checkExifAndLoadBase64Image;
    private loadImageFromURL;
    private transformOriginalImage;
    private transformImageBase64;
    private getTransformedSize;
    private setTransformedImage;
    imageLoadedInView(): void;
    private checkImageMaxSizeRecursively;
    private sourceImageLoaded;
    onResize(): void;
    private activatePinchGesture;
    private resizeCropperPosition;
    resetCropperPosition(): void;
    keyboardAccess(event: any): void;
    private changeKeyboardStepSize;
    private keyboardMoveCropper;
    private getPositionForKey;
    private getInvertedPositionForKey;
    private getEventForKey;
    startMove(event: any, moveType: MoveTypes, position?: string | null): void;
    startPinch(event: any): void;
    moveImg(event: any): void;
    onPinch(event: any): void;
    private setMaxSize;
    private setCropperScaledMinSize;
    private setCropperScaledMinWidth;
    private setCropperScaledMinHeight;
    private checkCropperPosition;
    moveStop(): void;
    pinchStop(): void;
    private move;
    private resize;
    private checkAspectRatio;
    private doAutoCrop;
    crop(): ImageCroppedEvent | null;
    private getImagePosition;
    private getOffsetImagePosition;
    private cropToBase64;
    private getQuality;
    private getResizeRatio;
    private getClientX;
    private getClientY;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ImageCropperComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<ImageCropperComponent, "image-cropper", never, { "format": "format"; "maintainAspectRatio": "maintainAspectRatio"; "transform": "transform"; "aspectRatio": "aspectRatio"; "resizeToWidth": "resizeToWidth"; "resizeToHeight": "resizeToHeight"; "cropperMinWidth": "cropperMinWidth"; "cropperMinHeight": "cropperMinHeight"; "canvasRotation": "canvasRotation"; "initialStepSize": "initialStepSize"; "roundCropper": "roundCropper"; "onlyScaleDown": "onlyScaleDown"; "imageQuality": "imageQuality"; "autoCrop": "autoCrop"; "containWithinAspectRatio": "containWithinAspectRatio"; "hideResizeSquares": "hideResizeSquares"; "cropper": "cropper"; "alignImage": "alignImage"; "disabled": "disabled"; "imageChangedEvent": "imageChangedEvent"; "imageURL": "imageURL"; "imageBase64": "imageBase64"; "imageFile": "imageFile"; "backgroundColor": "backgroundColor"; }, { "imageCropped": "imageCropped"; "startCropImage": "startCropImage"; "imageLoaded": "imageLoaded"; "cropperReady": "cropperReady"; "loadImageFailed": "loadImageFailed"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hZ2UtY3JvcHBlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiaW1hZ2UtY3JvcHBlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIsIFNhZmVTdHlsZSwgU2FmZVVybCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgQ3JvcHBlclBvc2l0aW9uLCBEaW1lbnNpb25zLCBJbWFnZUNyb3BwZWRFdmVudCwgSW1hZ2VUcmFuc2Zvcm0gfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IE1vdmVUeXBlcyB9IGZyb20gJy4uL2ludGVyZmFjZXMvbW92ZS1zdGFydC5pbnRlcmZhY2UnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSW1hZ2VDcm9wcGVyQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkluaXQge1xuICAgIHByaXZhdGUgc2FuaXRpemVyO1xuICAgIHByaXZhdGUgY2Q7XG4gICAgcHJpdmF0ZSBIYW1tZXI7XG4gICAgcHJpdmF0ZSBvcmlnaW5hbEltYWdlO1xuICAgIHByaXZhdGUgdHJhbnNmb3JtZWRJbWFnZTtcbiAgICBwcml2YXRlIG9yaWdpbmFsQmFzZTY0O1xuICAgIHByaXZhdGUgdHJhbnNmb3JtZWRCYXNlNjQ7XG4gICAgcHJpdmF0ZSBtb3ZlU3RhcnQ7XG4gICAgcHJpdmF0ZSBvcmlnaW5hbFNpemU7XG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1lZFNpemU7XG4gICAgcHJpdmF0ZSBzZXRJbWFnZU1heFNpemVSZXRyaWVzO1xuICAgIHByaXZhdGUgY3JvcHBlclNjYWxlZE1pbldpZHRoO1xuICAgIHByaXZhdGUgY3JvcHBlclNjYWxlZE1pbkhlaWdodDtcbiAgICBwcml2YXRlIGV4aWZUcmFuc2Zvcm07XG4gICAgcHJpdmF0ZSBhdXRvUm90YXRlU3VwcG9ydGVkO1xuICAgIHByaXZhdGUgc3RlcFNpemU7XG4gICAgc2FmZUltZ0RhdGFVcmw6IFNhZmVVcmwgfCBzdHJpbmc7XG4gICAgc2FmZVRyYW5zZm9ybVN0eWxlOiBTYWZlU3R5bGUgfCBzdHJpbmc7XG4gICAgbWFyZ2luTGVmdDogU2FmZVN0eWxlIHwgc3RyaW5nO1xuICAgIG1heFNpemU6IERpbWVuc2lvbnM7XG4gICAgaW1hZ2VWaXNpYmxlOiBib29sZWFuO1xuICAgIG1vdmVUeXBlczogdHlwZW9mIE1vdmVUeXBlcztcbiAgICB3cmFwcGVyOiBFbGVtZW50UmVmO1xuICAgIHNvdXJjZUltYWdlOiBFbGVtZW50UmVmO1xuICAgIGltYWdlQ2hhbmdlZEV2ZW50OiBhbnk7XG4gICAgaW1hZ2VVUkw6IHN0cmluZztcbiAgICBpbWFnZUJhc2U2NDogc3RyaW5nO1xuICAgIGltYWdlRmlsZTogRmlsZTtcbiAgICBmb3JtYXQ6ICdwbmcnIHwgJ2pwZWcnIHwgJ2JtcCcgfCAnd2VicCcgfCAnaWNvJztcbiAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBib29sZWFuO1xuICAgIHRyYW5zZm9ybTogSW1hZ2VUcmFuc2Zvcm07XG4gICAgYXNwZWN0UmF0aW86IG51bWJlcjtcbiAgICByZXNpemVUb1dpZHRoOiBudW1iZXI7XG4gICAgcmVzaXplVG9IZWlnaHQ6IG51bWJlcjtcbiAgICBjcm9wcGVyTWluV2lkdGg6IG51bWJlcjtcbiAgICBjcm9wcGVyTWluSGVpZ2h0OiBudW1iZXI7XG4gICAgY2FudmFzUm90YXRpb246IG51bWJlcjtcbiAgICBpbml0aWFsU3RlcFNpemU6IG51bWJlcjtcbiAgICByb3VuZENyb3BwZXI6IGJvb2xlYW47XG4gICAgb25seVNjYWxlRG93bjogYm9vbGVhbjtcbiAgICBpbWFnZVF1YWxpdHk6IG51bWJlcjtcbiAgICBhdXRvQ3JvcDogYm9vbGVhbjtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZztcbiAgICBjb250YWluV2l0aGluQXNwZWN0UmF0aW86IGJvb2xlYW47XG4gICAgaGlkZVJlc2l6ZVNxdWFyZXM6IGJvb2xlYW47XG4gICAgY3JvcHBlcjogQ3JvcHBlclBvc2l0aW9uO1xuICAgIGFsaWduSW1hZ2U6ICdsZWZ0JyB8ICdjZW50ZXInO1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIGltYWdlQ3JvcHBlZDogRXZlbnRFbWl0dGVyPEltYWdlQ3JvcHBlZEV2ZW50PjtcbiAgICBzdGFydENyb3BJbWFnZTogRXZlbnRFbWl0dGVyPHZvaWQ+O1xuICAgIGltYWdlTG9hZGVkOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgY3JvcHBlclJlYWR5OiBFdmVudEVtaXR0ZXI8RGltZW5zaW9ucz47XG4gICAgbG9hZEltYWdlRmFpbGVkOiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgY29uc3RydWN0b3Ioc2FuaXRpemVyOiBEb21TYW5pdGl6ZXIsIGNkOiBDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBvbkNoYW5nZXNJbnB1dEltYWdlO1xuICAgIHByaXZhdGUgaXNWYWxpZEltYWdlQ2hhbmdlZEV2ZW50O1xuICAgIHByaXZhdGUgc2V0Q3NzVHJhbnNmb3JtO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBpbml0Q3JvcHBlcjtcbiAgICBwcml2YXRlIGxvYWRJbWFnZTtcbiAgICBwcml2YXRlIGxvYWRJbWFnZUZpbGU7XG4gICAgcHJpdmF0ZSBpc1ZhbGlkSW1hZ2VUeXBlO1xuICAgIHByaXZhdGUgbG9hZEJhc2U2NEltYWdlO1xuICAgIHByaXZhdGUgY2hlY2tFeGlmQW5kTG9hZEJhc2U2NEltYWdlO1xuICAgIHByaXZhdGUgbG9hZEltYWdlRnJvbVVSTDtcbiAgICBwcml2YXRlIHRyYW5zZm9ybU9yaWdpbmFsSW1hZ2U7XG4gICAgcHJpdmF0ZSB0cmFuc2Zvcm1JbWFnZUJhc2U2NDtcbiAgICBwcml2YXRlIGdldFRyYW5zZm9ybWVkU2l6ZTtcbiAgICBwcml2YXRlIHNldFRyYW5zZm9ybWVkSW1hZ2U7XG4gICAgaW1hZ2VMb2FkZWRJblZpZXcoKTogdm9pZDtcbiAgICBwcml2YXRlIGNoZWNrSW1hZ2VNYXhTaXplUmVjdXJzaXZlbHk7XG4gICAgcHJpdmF0ZSBzb3VyY2VJbWFnZUxvYWRlZDtcbiAgICBvblJlc2l6ZSgpOiB2b2lkO1xuICAgIHByaXZhdGUgYWN0aXZhdGVQaW5jaEdlc3R1cmU7XG4gICAgcHJpdmF0ZSByZXNpemVDcm9wcGVyUG9zaXRpb247XG4gICAgcmVzZXRDcm9wcGVyUG9zaXRpb24oKTogdm9pZDtcbiAgICBrZXlib2FyZEFjY2VzcyhldmVudDogYW55KTogdm9pZDtcbiAgICBwcml2YXRlIGNoYW5nZUtleWJvYXJkU3RlcFNpemU7XG4gICAgcHJpdmF0ZSBrZXlib2FyZE1vdmVDcm9wcGVyO1xuICAgIHByaXZhdGUgZ2V0UG9zaXRpb25Gb3JLZXk7XG4gICAgcHJpdmF0ZSBnZXRJbnZlcnRlZFBvc2l0aW9uRm9yS2V5O1xuICAgIHByaXZhdGUgZ2V0RXZlbnRGb3JLZXk7XG4gICAgc3RhcnRNb3ZlKGV2ZW50OiBhbnksIG1vdmVUeXBlOiBNb3ZlVHlwZXMsIHBvc2l0aW9uPzogc3RyaW5nIHwgbnVsbCk6IHZvaWQ7XG4gICAgc3RhcnRQaW5jaChldmVudDogYW55KTogdm9pZDtcbiAgICBtb3ZlSW1nKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIG9uUGluY2goZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBzZXRNYXhTaXplO1xuICAgIHByaXZhdGUgc2V0Q3JvcHBlclNjYWxlZE1pblNpemU7XG4gICAgcHJpdmF0ZSBzZXRDcm9wcGVyU2NhbGVkTWluV2lkdGg7XG4gICAgcHJpdmF0ZSBzZXRDcm9wcGVyU2NhbGVkTWluSGVpZ2h0O1xuICAgIHByaXZhdGUgY2hlY2tDcm9wcGVyUG9zaXRpb247XG4gICAgbW92ZVN0b3AoKTogdm9pZDtcbiAgICBwaW5jaFN0b3AoKTogdm9pZDtcbiAgICBwcml2YXRlIG1vdmU7XG4gICAgcHJpdmF0ZSByZXNpemU7XG4gICAgcHJpdmF0ZSBjaGVja0FzcGVjdFJhdGlvO1xuICAgIHByaXZhdGUgZG9BdXRvQ3JvcDtcbiAgICBjcm9wKCk6IEltYWdlQ3JvcHBlZEV2ZW50IHwgbnVsbDtcbiAgICBwcml2YXRlIGdldEltYWdlUG9zaXRpb247XG4gICAgcHJpdmF0ZSBnZXRPZmZzZXRJbWFnZVBvc2l0aW9uO1xuICAgIHByaXZhdGUgY3JvcFRvQmFzZTY0O1xuICAgIHByaXZhdGUgZ2V0UXVhbGl0eTtcbiAgICBwcml2YXRlIGdldFJlc2l6ZVJhdGlvO1xuICAgIHByaXZhdGUgZ2V0Q2xpZW50WDtcbiAgICBwcml2YXRlIGdldENsaWVudFk7XG59XG4iXX0=